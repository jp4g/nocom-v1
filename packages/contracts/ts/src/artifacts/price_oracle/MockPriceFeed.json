{"transpiled":true,"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"MockPriceFeed","functions":[{"name":"change_admin","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"new_admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"7227578622619378060":{"error_kind":"string","string":"Only admin can change admin"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABEUnAgIEAScCAwQAHwoAAgADAEQtCEQBJQAAAEElAAAAZycCAQRFJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJiUAAADnHgIAAgAeAgADADMqAAIAAwAEJwICAQEkAgAEAAAAkCUAAAENJwICAAIvCgACAAMeAgAEAQoiBEMFFgoFBhwKBgcABCoHBAYnAgQBAAoqBQQHJAIABwAAAM4nAggEADwGCAEKKgYDBCQCAAQAAADgJQAAAR8wCgABAAImKAAABAR4RQwAAAQDJAAAAwAAAQwqAQABBdrF9da0SjJtPAQCASYqAQABBQZhOz0Lnb0zPAQCASYqAQABBWRNhHbDb2GMPAQCASY=","debug_symbols":"tVbbjqMwDP0XnvuQOFf3V1ZVRVs6QkK0YmClVcW/rzNDAoxkS3uZPpSThJz62MdpXtWtuUxv57a/P96r449XdRnarmvfzt3jWo/to6fZV6XSl1axOtpDpbWpjiE9aawVAfAENAGjM8AFWEvAJ4ALcI4AEvDECukd7zLAZSnYDGgGDIFoM8gzGD4BKMiAwgAKELTOABcAaTvO86HKus7j0DRJ1kYoyX/WQ9OP1bGfuu5Q/ay76eOl92fdfzzHeqBVEt30N3oS4b3tmoTmw7pb8Vu1AhWX7YQxFgrK645ECyRgQ+YAHzYU+zhAoIgq6MwRVVylBL/jMDyHAedw4SAcHMchSTGpQJ9hGGtZKe4/SPHfLAWiKVIUX5XIU4QYMkVAMiwTBApCjHeQhRiP/yzE8kIEm0fIJo/WFwKrvlgcJCGlTwx91iBI0o5DMqhCU0gUOjah2koksGaUOlazJIJHjfOqkDhv2LJIOfUu5zQaPqdBKCyCLgcHAvDmiFKrePClVbzl8yFHYtUaCQJHAkJCjM0JsXQMFgb3FwndBPA1oSCYNPjSrmFjc/jzCFDxJRUIsKQAveUlSM6MMRfCoPJsn4F4elKHFksYx/oKBEsYHXSJRAfP+gokc7qgdemz4Pa+OtGovrbD7nYzJ7ahrS9dswzvU3/drI6/nnkl346ew+Pa3KahSUzbKxJdIujEseaU7kc0oP9pi6c5/fRv"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["external","initializer","public"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"get_price","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"12011040883452936843":{"error_kind":"string","string":"Function get_price can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnbbhs5DIbfxde+kESRkvIqRVGkqVsEMJzATRZYFHn3JTX8ZTvAaF2nvYm/4UT/8KTD2L8233ZfX398eTx8f/q5ufv0a/P1+LjfP/74sn96uH95fDqo9dcm2J+qf/N2U3lzV7abplcx6GfVz7jdxEAOMQJEQUfEZBY2aA6UN3cpGTSHTIDqwLAwLAKLFIcSAeJgXi7AAHsEbTcpBkAG4FaCJcFCsFB1yAlQHDgCxEHwCGGACWo2UiFAdagJIA4tAhjgwylkACyRAMUhJQAsbKPYoDr0HHaApcBSYOmOdRCH7lgHXiCHALBHiEF1iAkgDj2ZVYHtVjMQh56xDhlQHbpjHTQc0nByjQBxaLA0t3CIAFgiLJYo0pZga8gFxIFgIXbIAaCOERlUB4tiAXGwclM2aA7m/AL2UE0UW1Y72NRZgBeQ6AmXXkqDFAFeAiFYyEsgOQC8BJK9BMIJ4CWQ4iWQ5iWQ5iUoIQAywEtQIgG8BCVFgKe3ECwES4Ylw8KwsJegSAR4CUqBpXgJSg0AL0GpXoLSEsBLUIONKgZWAo202jTvYPNigeJgqcvBFjMVzOpYlQQQhxIAGdAcqqYl20NrcTB/FnBLCwkAS4QlwpKsSZpBcejJ7MAAe6g2UrMqL2A+2xJsK+QCsHTnDSyZnAxUmW2Utd8CsHRXgy3dNmeceFADWRMw9yU+LglQElAetqxjWYw4DDrZVI+LkWSMkAqy6eI0bDUNKqA2bA0exBAG5UFQiRFjY59BtRMPaqC+AS1kCerUV/FmVMKgk80i6mT96TRsTfUkdPLZFFNIgwooDlsUUJ/9Cw0bhUF50FDOQ4XHWEGUyybUqdCgArJVtce77DY2lrAUxGW/6dT7YKEKSsNmLdzjJYIvRPCechw0bBwGIackwybDA2wIkcpQLkOl7/Pt7W27wZHly8txt7MTy9kZRk82z/fH3eFlc3d43e+3m3/u96/9n34+3x/658v9Ue9qBLvDN/1Uwe+P+53R2/Y0OqwPjSGF6sOVWx0S2mcXInEikmz+LhpJypnEpR9pIlFDidCooZ5CKXKhQesalNjK2jWUC69pzEKhlOEG5bwaCv+BUOQvh5IqjVDCelXqukSpBRK6e7U1J9okEBJb0pdASNqHA8nrgUzaXPcxdGiLua03+aRFUyNCbyjzal3jrEd1peGRD8p1TeTaYDiuBjOb9jnCC91E0pDI4V0+Jj0qVOCG5HRWlsqXGmXih+2zS0bDyQvidKkwa9FcsH4VTqf20nl8qTFr0tGievwfCokuK5Im+dS3Mkz5lEJb15i0OSfMeKZwm0IbBYl8WxypwgndvNO6Rp7VNGFDinw2XX9PQ9rQqO02DT0GjGUj1XWNMusudIa+F9yk0DImmp54b1LQbTmNHVrW60qTuuYs6M+czzf59hvpzKedkW8sK40OVaw3afyJUCKNDo253jZTShxLV5nMV5K/qxFFRixS6m0aZWzz+oKwPuupfXSmzBSumykzhWtnSk4fbq9pOttp4WlpPZ3TzZUDQhE9Cq5urnlyEJVC8EO76/yc8C4dsxatcWwIleQsHXzTWYPXzxq5zo5N4y1FT0206kae7fKh0RAJjVePsxxmIul0ntX3pbgqEmfnDRnVVabVQ/H/hJPOwil51ROavas0Ga0aT3mlEq6ft2GcRtONM1+QjVb4o2vHRGG6T18VxVThqiiuPCu8V/isl/cPj8eL3zjeTOr4eP91v/PL76+Hh7O7L/8+4w5+I3k+Pj3svr0ed6Z0+qFE/3yiwFt9O/ls31Tppb7jbPULAbuMdle/ktVj1Oc3c+Y/"},{"name":"get_prices","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"asset_addresses","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":2,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"6610754467869895375":{"error_kind":"string","string":"Function get_prices can only be called statically"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"process_message","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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"},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"4299781351303442458":{"error_kind":"string","string":"Only admin can set prices"},"6610754467869895375":{"error_kind":"string","string":"Function get_prices can only be called statically"},"7227578622619378060":{"error_kind":"string","string":"Only admin can change admin"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"12011040883452936843":{"error_kind":"string","string":"Function get_price can only be called statically"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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"},{"name":"set_price","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"asset_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"price","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"4299781351303442458":{"error_kind":"string","string":"Only admin can set prices"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBHJwAABEcnAgMEAicCBAQAHwoAAwAEAEUcAEZGBi0IRQEtCEYCJQAAAEolAAAAdScCAQRHJwICBAA7DgACAAEsAABDADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAJwBEBAMmJQAABcweAgADAB4CAAQAMyoAAwAEAAUnAgMBASQCAAUAAACeJQAABfInAgQAAi8KAAQABR4CAAQBCiIEQwYWCgYHHAoHCAAEKggEBycCBAEACioGBAgkAgAIAAAA3CcCCQQAPAYJAQoqBwUGJAIABgAAAO4lAAAGBCcCBQAALQgBBicCBwQEAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgAIggCCC0OBQgAIggCCC0OBQgrAgAHAAAAAAAAAAACAAAAAAAAAAAtCAEIJwIJBAUACAEJAScDCAQBACIIAgktCgkKLQ4FCgAiCgIKLQ4FCgAiCgIKLQ4FCgAiCgIKLQ4HCi0IAQcAAAECAS0OBgctCAEGAAABAgEtDggGLQgBCQAAAQIBJwIKBAAtDgoJLQgBCwAAAQIBLQ4ECycCDAABJwINBAEkAgAEAAACDCMAAAHFLQgBDicCDwQEAAgBDwEnAw4EAQAiDgIPLQoPEC0ODBAAIhACEC0OBRAAIhACEC0OBRAtDg4HLQ4IBi0ODQktDgQLIwAAApgtCgoIIwAAAhUMIghEDiQCAA4AAAVGIwAAAictCwcILQsGDi0LCw8tCw4QACIQAhAtDhAOLQgBECcCEQQFAAgBEQEnAxAEAQAiDgIRJwISBAQAIhACEz8PABEAEy0CCAMnAAQEBCUAAAYWLQgFDgAqDg0RLQ4MES0ODgctDhAGLQ4NCS0ODwsjAAACmC0LBwgtCwYMLQsLDgoqDgQPJAIADwAAAronAhAEADwGEAEkAgAEAAAC/CMAAALHJwIOBAItAggDJwAEBAQlAAAGFi0IBQ8AKg8OEC0OARAtDg8HLQ4MBi0ODgktDgQLIwAAA4gtCgoIIwAAAwUMIghEDCQCAAwAAATAIwAAAxctCwcILQsGDC0LCw4tCwwPACIPAg8tDg8MLQgBDycCEAQFAAgBEAEnAw8EAQAiDAIQJwIRBAQAIg8CEj8PABAAEi0CCAMnAAQEBCUAAAYWLQgFDAAqDA0QLQ4BEC0ODActDg8GLQ4NCS0ODgsjAAADiC0LCwgKKggEDCQCAAwAAAOiJwIOBAA8Bg4BLQoKASMAAAOrDCIBRAgkAgAIAAAEOiMAAAO9LQsHAS0LBggtCwkKLQsIDAAiDAIMLQ4MCC0IAQwnAg4EBQAIAQ4BJwMMBAEAIggCDicCDwQEACIMAhA/DwAOABAtDgEHLQ4MBi0OCgktDgMLACoMDQMtCwMBCioBBQMKKgMEBSQCAAUAAAQuJQAABnocCgIDADAKAAMAASYtCwcILQsGCi0LCQwtCwsODCoBDA8kAgAPAAAEXCMAAASyACIKAhAAKhABES0LEQ8AIggCEQAqEQESLQsSEAAqDxARLQIKAycABAQFJQAABhYtCAUPACIPAhAAKhABEi0OERItDggHLQ4PBi0ODAktDg4LIwAABLIAKgENCC0KCAEjAAADqy0LBwwtCwYOLQsJDy0LCxAMKggPESQCABEAAATiIwAABTgAIg4CEgAqEggTLQsTEQAiDAITACoTCBQtCxQSACoREhMtAg4DJwAEBAUlAAAGFi0IBREAIhECEgAqEggULQ4TFC0ODActDhEGLQ4PCS0OEAsjAAAFOAAqCA0MLQoMCCMAAAMFLQsHDi0LBg8tCwkQLQsLEQwqCBASJAIAEgAABWgjAAAFvgAiDwITACoTCBQtCxQSACIOAhQAKhQIFS0LFRMAKhITFC0CDwMnAAQEBSUAAAYWLQgFEgAiEgITACoTCBUtDhQVLQ4OBy0OEgYtDhAJLQ4RCyMAAAW+ACoIDQ4tCg4IIwAAAhUoAAAEBHhHDAAABAMkAAADAAAF8SoBAAEF2sX11rRKMm08BAIBJioBAAEFBmE7PQudvTM8BAIBJioBAAEFO6vkW5hKcBo8BAIBJi0BAwYKAAYCByQAAAcAAAYsIwAABjUtAAMFIwAABnktAAEFAAABBAEAAAMECS0AAwotAAULCgAKCQwkAAAMAAAGby0BCggtBAgLAAAKAgoAAAsCCyMAAAZLJwEFBAECAAYCBiYqAQABBbq7IdeCMxhkPAQCASY=","debug_symbols":"tZlRbhs5DIbv4mc/SKJISblKURRu6hYGDCdwkwUWQe6+pIbk2FlISJz2Jf5MZ/4hRVLi2C+bH/vvz7++HU4/H35v7r68bL6fD8fj4de348P97unwcGLryybIn5jS5i5v+bVs7gq/Ar+PgSHz5zEKoAKCQWUgBgKDxtAYSt7cJfmf0hQq6Ee1KjS2JBCoC6SglhSjASkkdiNlAVQAMODLgW+RMhgUBUwGZiGzkFlKNECFGgyyQVMQnyFtNxCzQVVI9lEyC5gFzJKTASlgNEAFCgZ2C1nVDkUEg0BRqMmAFFowQIO2QA5gUBWiWaIK5hQNVDBLuiELFIW+hh3MUsxSzFKjASp0xzpkg7YAdsdQoChIASyACn0xuTKxr1gVQIOmIHW4QFHojnXgcDKHg5LcBVChmaWphUIwMEs0ixRk5kogKcgFUAHMAtmgKUhl5iRQFCSKBVBB0p1BoCqI8wvITXmhSFZ1gaYgiylQoi54EQ87pGCgKShgFsgGmoKSNQUlawoKRgNNQSmagtI0BaWhgaagBjDQFNSYDDQFNQUDXd4KZgGzZLNks6BZUFNQKRhoCmoxS8kGmoJaNQW1agpqiwaaghbkKhKQFHCkTRqkg/TFAqTQk8v7WJO+QHasUTRAg6YgS7dAVZDORbmpdG4H8WcBtcQQopPbotui2/ruXTuRUV/ThbKT3F223CD5VhL3ZfMOslsqua2H0knWlkIntlG/VoKQNWAio95OC2Unvi/J8RK7z6ISU3Rym/hM2AmNstsy6xF1anYFglM1IrdRMZJeUnJbdQ8qOrlyM5UU7Np+HEkHxH4eKWWnaiSnJ3WSqpXqZ0Ijcpv0PC3UjIrbpFZI1i9VsCtqMWrJyWwQohMZRbdFdGpGCZxcBfxatCgBs5NFCf0cWIg0XuhHZr+2+j2a23od1D5VgJPbZKfo8S7HUbel6GReZXAbWEQ5B6fVZh4sZ9hCrkyuUvq1r6/bjQ1G357O+73MRReTEs9Pj7vz/vS0uTs9H4/bzT+743P/p9+Pu1N/fdqd+VOulP3pB7+y4M/DcS/0ul2vDuNLuX9D1cuZW3UJ7ogrkTgRSbI/LRo85lxIXPuRJhK8fUfTqKGuoRS60oCxBnDFN9VgLjjSmIUCMuEtbkDOw1DwD4RCfzkUbmIPJYyzUscSpRaTKC21kRNtEgiQHBhLIDxXfjqQPA5kVua8C5sEbyguwbvCtRdpFop3Cg/asLrBQV1pzEo0NHCR0HC4pDHPRNK6ptyzcSgyqVJACi7Cc+wwMdNVRW8WPu/Gq1omGjzoeGoaP2wNg6mzdqFE3i6Uxysy9ySH1ZOWRiJpsiSQUSX4cCFXwJuWtMbhkqZJoRbypi2rCznd5EMbp3UmkSD5iZDbOIxJhRI/dKoG5XTR9vV6NdNkH41oZcEzlSsAXq9FmlQFP55Ywxa8qE4+J641ZuXp7ZrjmpAEb8pqso2m2OxI4UGwDTVgkhNMdqIghNsUmick4m1x8BcbFgdcZOR/XsAsp8nbFC+Og49pUHON2m7T4A3cj6VUxxo0qy6rjJLpJoXmG07D23yQhzmfAGmcV5jkNfNwayWeL4fI9oHlzOvkhTemFbxCZfS/SeNPhBLBKzTmelunlOhbV5n0a8a/qxGJPBYq9TaN4mMkfz077vpcP9spM4X3dcpM4b2dgvHT5TVdzrZuPDwxjctrdriiT3/8hWAbHq44mUOpgPnB1RUv5vI3yzEr0Rr9QKhAw6H6vbNGCcNZAyenPNRqVc7fZ4/dwOkQCsVF+DeC4XMftlmrNLx4dlzHjRI+4gjA6ggOR2qa1CnEEj2aWGg4UtPskQlLjP6QwfPTSGTat8H29JZu7HyyAmkFP7t3TBSm5/S7opgqvCuKd84KbxW+8tvd/eF89Uvdq0idD7vvx72+/fl8ur/49OnfR/vEful7PD/c7388n/eitP7cx3++8NeBWwD8Kt/PytsAW36klrdR3rLn/LvV11dx5j8="},{"name":"set_prices","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"asset_addresses","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"prices","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"4299781351303442458":{"error_kind":"string","string":"Only admin can set prices"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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"},{"name":"sync_private_state","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"MockPriceFeed"}},{"name":"fields","value":{"fields":[{"name":"assets","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"MockPriceFeed::change_admin_parameters"}}],"kind":"struct","path":"MockPriceFeed::change_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"MockPriceFeed::constructor_parameters"}}],"kind":"struct","path":"MockPriceFeed::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"MockPriceFeed::get_price_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"MockPriceFeed::get_price_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_addresses","type":{"fields":[{"name":"storage","type":{"kind":"array","length":2,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}}],"kind":"struct","path":"MockPriceFeed::get_prices_parameters"}},{"name":"return_type","type":{"fields":[{"name":"storage","type":{"kind":"array","length":2,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}}],"kind":"struct","path":"MockPriceFeed::get_prices_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_ciphertext","type":{"fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"message_context","type":{"fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext"}}],"kind":"struct","path":"MockPriceFeed::process_message_parameters"}}],"kind":"struct","path":"MockPriceFeed::process_message_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"price","type":{"kind":"integer","sign":"unsigned","width":128}}],"kind":"struct","path":"MockPriceFeed::set_price_parameters"}}],"kind":"struct","path":"MockPriceFeed::set_price_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_addresses","type":{"fields":[{"name":"storage","type":{"kind":"array","length":4,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"prices","type":{"fields":[{"name":"storage","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":128}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}}],"kind":"struct","path":"MockPriceFeed::set_prices_parameters"}}],"kind":"struct","path":"MockPriceFeed::set_prices_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"MockPriceFeed::sync_private_state_parameters"}}],"kind":"struct","path":"MockPriceFeed::sync_private_state_abi"}]}},"file_map":{"104":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr","source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"},"105":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr","source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"},"110":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"113":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"},"116":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr","source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"},"118":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr","source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"},"119":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr","source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"},"120":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr","source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"},"121":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr","source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"},"122":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr","source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"},"123":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr","source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"},"124":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr","source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"},"125":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr","source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"},"142":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr","source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"},"162":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr","source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"},"164":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"},"166":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"},"174":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr","source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"},"179":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr","source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"},"181":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/version.nr","source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"},"185":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"},"19":{"path":"std/hash/mod.nr","source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"195":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"215":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr","source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"},"218":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr","source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"},"219":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr","source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"},"221":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr","source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"},"222":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr","source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"},"225":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"},"236":{"path":"/home/jpag/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr","source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"258":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"299":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"},"314":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"},"324":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"},"337":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr","source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"},"338":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr","source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"},"340":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr","source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"},"352":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"368":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"},"370":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"},"371":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"},"389":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"},"393":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"403":{"path":"/home/jpag/Workground/nocom/basic/packages/contracts/contracts/price_oracle/src/main.nr","source":"use aztec::macros::aztec;\n\n#[aztec]\npub contract MockPriceFeed {\n    use aztec::{\n        macros::{functions::{external, initializer, view}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, PublicMutable},\n    };\n\n    global MAX_ASSETS_PER_CALL: u32 = 4; // just set based on nocom for prototype\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        assets: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        admin: PublicMutable<AztecAddress, Context>,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n    }\n\n    #[external(\"public\")]\n    fn change_admin(new_admin: AztecAddress) {\n        let admin = storage.admin.read();\n        assert(context.msg_sender().unwrap() == admin, \"Only admin can change admin\");\n        storage.admin.write(new_admin);\n    }\n\n    // set a single price\n    #[external(\"public\")]\n    fn set_price(asset_address: AztecAddress, price: u128) {\n        let admin = storage.admin.read();\n        assert(context.msg_sender().unwrap() == admin, \"Only admin can set prices\");\n        storage.assets.at(asset_address).write(price);\n    }\n\n    // get a single prices\n    #[external(\"public\")]\n    #[view]\n    fn get_price(asset_address: AztecAddress) -> u128 {\n        storage.assets.at(asset_address).read()\n    }\n\n    // set multiple prices\n    #[external(\"public\")]\n    fn set_prices(\n        asset_addresses: BoundedVec<AztecAddress, MAX_ASSETS_PER_CALL>,\n        prices: BoundedVec<u128, MAX_ASSETS_PER_CALL>,\n    ) {\n        let admin = storage.admin.read();\n        assert(context.msg_sender().unwrap() == admin, \"Only admin can set prices\");\n\n        for i in 0..asset_addresses.len() {\n            let asset_address = asset_addresses.get_unchecked(i);\n            let price = prices.get_unchecked(i);\n            storage.assets.at(asset_address).write(price);\n        }\n    }\n\n    // get multiple prices\n    #[external(\"public\")]\n    #[view]\n    fn get_prices(\n        asset_addresses: BoundedVec<AztecAddress, 2>,\n    ) -> BoundedVec<u128, 2> {\n        let mut prices: BoundedVec<u128, 2> = BoundedVec::new();\n        for i in 0..asset_addresses.len() {\n            if i < asset_addresses.len() {\n                let asset_address = asset_addresses.get_unchecked(i);\n                let price = storage.assets.at(asset_address).read();\n                prices.push(price);\n            }\n        }\n        prices\n    }\n}\n"},"42":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"43":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"5":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"},"6":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"},"67":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr","source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"},"76":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"78":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr","source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"},"81":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr","source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"83":{"path":"/home/jpag/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"}}}